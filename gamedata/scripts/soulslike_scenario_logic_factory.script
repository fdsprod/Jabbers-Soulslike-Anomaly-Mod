local ignore_list = {
    ["bolt"] = true,
    ["itm_actor_backpack"] = true, -- Quick Release
    ["device_pda"] = true,
    ["device_pda_1"] = true,
    ["device_pda_2"] = true,
    ["device_pda_3"] = true,
    ["wpn_knife"] = true,
}

---------------------------------------------------------
-- Base Scenario Class 
---------------------------------------------------------

class "SoulslikeScenarioLogic"

function SoulslikeScenarioLogic:__init(state)    
    if state then 
        self.logic_state = state
        soulslike.debug("Scenario created with state:")
        soulslike.debug(state)
    else
        self.logic_state = {}
        soulslike.debug("Scenario created without state.")
    end
    
    self.game_state = soulslike.get_soulslike_state()
end

function SoulslikeScenarioLogic:destroy()
    soulslike.debug("Destroying scenario")
	self.logic_state = nil
    self.game_state = nil
end

function SoulslikeScenarioLogic:HealActor()
    soulslike.debug("SoulslikeScenarioLogic:HealActor")
    local heath = 1 - soulslike_mcm.get_health_loss_percent()

	db.actor:set_health_ex(heath)
	db.actor.power = 1
	db.actor.radiation = 0
	db.actor.bleeding = 1
	db.actor.psy_health = 1

    save_var(db.actor,'grw_in_water',nil)
	
    arszi_psy.set_psy_health(1.0)
end

function SoulslikeScenarioLogic:ApplyRankLoss()
    local rank = db.actor:character_rank()
    local loss_percent = soulslike_mcm.rank_loss_percent()
    local rank_loss = math.abs(rank * loss_percent)

    soulslike.debug("Player has lost "..tostring(rank_loss).." rank.")

	db.actor:set_character_rank(db.actor:character_rank() + (-rank_loss or 0))
	game_statistics.check_for_rank_change()
end

function SoulslikeScenarioLogic:ApplyRepLoss()
    local rep = db.actor:character_reputation()
    local loss_percent = soulslike_mcm.rep_loss_percent()
    local rep_loss = math.abs(rep * loss_percent)

    soulslike.debug("Player has lost "..tostring(rep_loss).." repuation.")

	db.actor:set_character_reputation(db.actor:character_reputation() + (-rep_loss or 0))
	game_statistics.check_for_reputation_change()
end

function SoulslikeScenarioLogic:ApplyItemConditionLoss(item, condition_loss_percent)
    local cond = item:condition()
    local sec = item:section()
    local degrade_factor = cond * condition_loss_percent
    local is_grenade = IsGrenade(item)
    local is_weapon = (IsWeapon(item) and not is_grenade)
    local is_outfit = IsOutfit(item) 
    local is_headgear = IsHeadgear(item)
    
    local use_condition = utils_item.is_degradable(item, sec)
    local has_cond = use_condition or is_weapon or is_outfit or is_headgear

    if has_cond then
        soulslike.debug("Degrading ".. sec.. " condition ".. tostring(cond).." by "..tostring(degrade_factor))
        -- utils_item.degrade releases the item if the condition is 0
        local condition = utils_item.degrade(item, degrade_factor)
        return condition
    end

    -- No condition to be returned.
    return nil
end

function SoulslikeScenarioLogic:ApplyItemPreconditions()
    local is_magazine					= magazine_binder and magazine_binder.is_magazine
    local is_carried_mag				= magazine_binder and magazine_binder.is_carried_mag
    local toggle_carried_mag			= magazine_binder and magazine_binder.toggle_carried_mag

    local function check_item(_, item)
        local sec = item:section()
        if is_magazine and is_magazine(sec) and is_carried_mag(item:id()) then
            soulslike.debug("Toggling carried mag: "..sec)
            local result = toggle_carried_mag(item:id())
            soulslike.debug("Mag toggled to: "..tostring(result))
        end
    end

    soulslike.debug("Inventory precondition checks")
    db.actor:iterate_inventory(check_item)
end

function SoulslikeScenarioLogic:HandleItemsAndRespawn()
    -- Override in other scenarios
end

function SoulslikeScenarioLogic:OnDeath()    
    self:HealActor()
    self:ApplyRankLoss()
    self:ApplyRepLoss()
    self:ApplyItemPreconditions()
    self:HandleItemsAndRespawn()
end

function SoulslikeScenarioLogic:OnComplete()
	-- Satiety
	local conditions = db.actor:cast_Actor():conditions()
	local satiety = conditions:GetSatiety()
	local red_icon_satiety = conditions:SatietyCritical() * 0.5
	
    satiety = normalize(satiety, red_icon_satiety, 1)
    satiety = math.clamp( satiety / 5.65 , 0, 0.185)

    soulslike.debug({satiety = satiety})
    if satiety < 0.5 then
        self.logic_state.gave_food_or_water = true  
        --debug("HACK updating satiety.")
	    db.actor.satiety = 0.5
    end

	-- Thirst
	local thirst = 1 - actor_status_thirst.get_water_deprivation()		-- 1 full
	local red_icon_thirst = 5760
	red_icon_thirst = 1 - normalize(red_icon_thirst, 0, 10000)		-- def 0.424 red
	
    thirst = normalize(thirst, red_icon_thirst, 1)
    thirst = math.clamp(thirst / 5.65, 0, 0.185)

    soulslike.debug({thirst = thirst})

    if thirst < 0.5 then
        self.logic_state.gave_food_or_water = true  
        -- HACK... deal with it :shades:
        soulslike.debug("HACK updating thirst.")
        actor_status_thirst.load_state({drink = {last_drink = 3500, chk_drink = nil}})
        actor_status_thirst.actor_on_update()
    end

    if self.logic_state.gave_food_or_water then
        soulslike.debug("Spawning bread and water on actor.")
        alife_create_item('bread', db.actor)
        alife_create_item('water_drink', db.actor)
    end

    actor_status.activate_hud()

    self:SendWakeupMessage()
    self:destroy();
end

function SoulslikeScenarioLogic:RespawnActor()
    soulslike.debug("Respawning actor at last sleep location")
    soulslike.debug(self.game_state)
        
    local position = vector():set(self.game_state.spawn_location.position.x, self.game_state.spawn_location.position.y, self.game_state.spawn_location.position.z)   
    local level_vertex_id = self.game_state.spawn_location.level_vertex_id
    local game_vertex_id = self.game_state.spawn_location.game_vertex_id  
    
    level.add_pp_effector("black_infinite.ppe", 5606, true)
    actor_status.deactivate_hud()

    local function respawn()
        ChangeLevel(position, level_vertex_id, game_vertex_id, VEC_ZERO, false)
        return true
    end
    CreateTimeEvent(0, "respawn", 1, respawn)

    self:StopSurgeAndStorm()
end

function SoulslikeScenarioLogic:SendWakeupMessage()
    local rescuer = soulslike.find_actor_community_friendly()
    local msg = soulslike_message_factory.create(rescuer, self.logic_state)

    if rescuer then
        news_manager.send_tip(db.actor, msg, nil, rescuer, 20000)
    else
		local ui_sender = news_manager.tips_icons['default']
        db.actor:give_game_news("", msg, ui_sender, 0, 20000)
    end  
end

function SoulslikeScenarioLogic:AdvanceTime()
    soulslike.debug("SoulslikeScenarioLogic:AdvanceTime")
    self.logic_state.is_advancing_time = true

    xr_effects.disable_ui(db.actor, nil)

    level.add_cam_effector("camera_effects\\sleep.anm", 10, false, "soulslike.dream_callback")
    level.add_pp_effector("sleep_fade.ppe", 11, false)

    _G.mus_vol = get_console_cmd(2,"snd_volume_music")
    _G.amb_vol = get_console_cmd(2,"snd_volume_eff")

    exec_console_cmd("snd_volume_music 0")
    exec_console_cmd("snd_volume_eff 0")

    level.add_pp_effector("surge_fade.ppe", 11, false) 
    db.actor:give_info_portion("actor_is_sleeping")
end

function SoulslikeScenarioLogic:StopSurgeAndStorm(to_id)
    -- skip surge due to bug with killing actor on switch
    surge_manager.stop_surge()    
    if (psi_storm_manager.get_psi_storm_manager().started) then
        psi_storm_manager.get_psi_storm_manager().finish(true)
    end
end

function SoulslikeScenarioLogic:TransferItems(to_id)
    local rank = db.actor:character_rank()
    local ranked_chance = math.clamp(math.sqrt(rank / 500) * math.log(rank * rank)/math.log(1000) * 1.5, 0, 50) / 66;
    local item_condition_loss_percent = soulslike_mcm.get_item_condition_loss_percent()
    local item_loss_scalar = soulslike_mcm.get_item_loss_scalar()
    local backpack = level.object_by_id(to_id)
    local enemy_looter = soulslike.find_enemy()
    local enemy_looted = false
    
    local function release_actor_item(temp, item)
        local sec = item:section()

        if ignore_list[sec] then
            soulslike.debug("Item is in ignore list: "..sec)
            return
        end

        if ini_sys:r_bool_ex(sec,"quest_item",false) then
            soulslike.debug("Item quest item: "..sec)
            return
        end
        
        local loss_chance_dice_roll = math.random(0, 100)
        local loss_chance = math.floor(ranked_chance * item_loss_scalar * 100)
        
        loss_chance = math.clamp(loss_chance, 0, 100)

        if soulslike_mcm.debug_item_loss() then
            loss_chance = 100
        end

        soulslike.debug("item_loss_scalar: "..item_loss_scalar.." loss_chance_dice_roll: "..loss_chance_dice_roll.." rank: "..rank.." ranked_chance: "..ranked_chance.." loss_chance: "..loss_chance);

        local is_grenade = IsGrenade(item)
        local is_artefact = IsArtefact(item)
        local is_weapon = (IsWeapon(item) and not is_grenade)
        local is_outfit = IsOutfit(item) 
        local is_headgear = IsHeadgear(item)
        local is_backpack = item and SYS_GetParam(0, sec, "kind") == "i_backpack"
        local is_toolkit = soulslike.IsToolkit(item)
        local is_loss_allowed = true

        if is_weapon and not soulslike_mcm.allow_weapon_loss() then   
            soulslike.debug("Not allowed to lose weapon "..sec)
            is_loss_allowed = true
        end

        if is_artefact and not soulslike_mcm.allow_artifact_loss() then   
            soulslike.debug("Not allowed to lose artefact "..sec)
            is_loss_allowed = true
        end

        if is_outfit and not soulslike_mcm.allow_outfit_loss() then   
            soulslike.debug("Not allowed to lose outfit "..sec)
            is_loss_allowed = true
        end

        if is_headgear and not soulslike_mcm.allow_headgear_loss() then   
            soulslike.debug("Not allowed to lose headgear "..sec)
            is_loss_allowed = true
        end

        if is_toolkit and not soulslike_mcm.allow_toolkit_loss() then   
            soulslike.debug("Not allowed to lose toolkit "..sec)
            is_loss_allowed = true
        end
        
        if is_backpack then            
            soulslike.debug("Not allowed to lose bakcpack "..sec)
            is_loss_allowed = true
        end

        -- We never want to delete the players backpack
        -- since it makes up the created stash
        if is_loss_allowed and loss_chance ~= 0 and loss_chance_dice_roll < loss_chance then
            self.logic_state.items_lost = true                
            loss_chance_dice_roll = math.random(0, 100)

            -- I call this The Tarkov Looter... 
            -- This shit is going to be funny as fuck for me to know that there is a 1% chance for this to happen 
            if loss_chance_dice_roll <= 1 and is_weapon and item_parts then
                local parts = item_parts.get_parts_con(item)
                if parts then
                    local keys = {}
                    local numitems = 0 
                    for k,v in pairs(parts) do
                        numitems = numitems + 1
                        table.insert(keys, k)
                    end
                    local index = math.random(1, numitems)
                    parts[keys[index]] = -1 -- KEKW
                    enemy_looted = true     
                    -- TODO: Add message text for this 
                    self.logic_state.got_tarkoved = true
                end    
                
                soulslike.debug("Transfering item "..sec)
                db.actor:transfer_item(item, backpack)
                return       
            else
                local allow_npc_looting = soulslike.mcm.lost_items_looted_by_npcs()

                if(allow_npc_looting and (is_weapon or is_outfit or is_headgear or is_toolkit) and enemy_looter) then   
                    soulslike.debug("Transfering item to enemy: "..sec)   
                    table.insert(self.logic_state.game_state.created_stashes[to_id].lost_items, sec)                
                    db.actor:transfer_item(item, enemy_looter)
                    enemy_looted = true
                else
                    soulslike.debug("Item lost "..sec)  
                    table.insert(self.logic_state.game_state.created_stashes[to_id].lost_items, sec)          
                    alife_release(item)
                end
            end
            
            return   
        end

        if item_condition_loss_percent > 0 then
            local condition_loss_percent = math.clamp(ranked_chance * item_condition_loss_percent, 0, 1)
            local condition = self:ApplyItemConditionLoss(item, condition_loss_percent)
                
            if condition == 0 then
                soulslike.debug("Item ".. sec.. " was degraded into oblivion")
                self.logic_state.items_lost = true
                table.insert(self.logic_state.game_state.created_stashes[to_id].lost_items, sec)
                return;
            end
        end
            
        soulslike.debug("Transfering item "..sec)
        db.actor:transfer_item(item, backpack)
    end     
    
    soulslike.debug("Transfering items")
    db.actor:iterate_inventory(release_actor_item)

    if enemy_looter and enemy_looted then        
        self.logic_state.enemy_looter_name = enemy_looter:character_name()
        self.logic_state.enemy_looter_comm = enemy_looter:character_community()

        if soulslike_mcm.are_looter_npcs_marked() then
            level.map_add_object_spot_ser(enemy_looter:id(), "secondary_task_location", self.logic_state.enemy_looter_name)            
        end
    end
end

function SoulslikeScenarioLogic:OnRespawn()
    soulslike.debug("SoulslikeScenarioLogic:OnRespawn")

    bind_stalker_ext.invulnerable_time = time_global() + 1

    self:HealActor()
    self:AdvanceTime()
    
    local rank = db.actor:character_rank()
    local rep = db.actor:character_reputation()

    soulslike.debug('Character rank: '..rank)
    soulslike.debug('Character rep: '..rep)
end 

---------------------------------------------------------
-- Default Scenario 
-- Stash dropped where the player died
-- Marked on PDA
---------------------------------------------------------

class "DefaultSoulslikeScenarioLogic" (SoulslikeScenarioLogic)

function DefaultSoulslikeScenarioLogic:__init(state) super (state)
	self.logic_state.scenario_id = soulslike.SCENARIOS.Legacy
end

function DefaultSoulslikeScenarioLogic:CreateStash()
    soulslike.debug("Creating stash")    

    local actor = db.actor
    local se_stash = alife_create("inv_backpack", actor:position(), actor:level_vertex_id(), actor:game_vertex_id())  
    
    if (se_stash) then
        self.game_state.created_stashes[se_stash.id] = {
            lost_items = {},
            examine = false
        } 
    end

    return se_stash
end

function DefaultSoulslikeScenarioLogic:HandleItemsAndRespawn() 
    local se_stash = self:CreateStash()
             
    if se_stash then
        soulslike.debug("Stash created "..tostring(se_stash.id))

        local function transfer_and_respawn()
            local pack = level.object_by_id(se_stash.id)

            if pack then
                soulslike.debug("Stash exists in game")

                self:TransferItems(se_stash.id)   
                
                self.logic_state.has_pda_marker = true
                level.map_add_object_spot_ser(se_stash.id, "primary_object", db.actor:character_name() .. " items")

                self:RespawnActor()
                return true
            else
                soulslike.debug("Stash does not yet exist in game")            
                return false
            end
        end
        
        --We have to create a timer to give the game time to spawn the backpack.
        CreateTimeEvent(0, "transfer_and_respawn", 0, transfer_and_respawn)
    else    
        soulslike.debug("Stash was not created")
        self:RespawnActor()
    end
end

---------------------------------------------------------
-- RF Detector Scenario 
-- Hidden stash used for item drop
-- RF Detector must be used to find the stash
-- TODO: Add task to the players PDA
---------------------------------------------------------

class "RFDetectorSoulslikeScenarioLogic" (SoulslikeScenarioLogic)

function RFDetectorSoulslikeScenarioLogic:__init(state) super (state)
	self.logic_state.scenario_id = soulslike.SCENARIOS.RFDetectorStash
end

function RFDetectorSoulslikeScenarioLogic:CreateStash()
     -- For some reason, "box_in_same_map" doesn't actually mean same map in the treasure_manager.
    local old_box_in_same_map = treasure_manager.box_in_same_map
    treasure_manager.box_in_same_map = function(id)
        local obj1 = alife():actor()
        local obj2 = alife_object(id)
        return simulation_objects.is_on_the_same_level(obj1, obj2)
    end
    local id = treasure_manager.get_random_stash("treasure", nil ,true, true)
    treasure_manager.box_in_same_map = old_box_in_same_map

    -- If we could not grab a ransom stash, we need to return nil so we don't transfer anything
    if not id then return nil end

    soulslike.debug("Random stash found: "..tostring(id))    

    local actor = db.actor
    local se_stash = alife_create("hidden_box", actor:position(), actor:level_vertex_id(), actor:game_vertex_id())

    if not self.game_state.hidden_stashes then
        self.game_state.hidden_stashes = {}
    end

    self.game_state.hidden_stashes[id] = {
        stash_id = se_stash.id,
        radio_id = id
    } 

    if soulslike_mcm.debug_hidden_stashes() then
        level.map_add_object_spot_ser(id, "secondary_task_location", "DEBUG: RF DETECTOR STASH.") 
    end          
        
    return se_stash
end

function RFDetectorSoulslikeScenarioLogic:HandleItemsAndRespawn() 
    local se_stash = self:CreateStash()
             
    if se_stash then
        soulslike.debug("Hidden stash found "..tostring(se_stash.id))

        local function transfer_and_respawn()
            local pack = level.object_by_id(se_stash.id)

            if pack then
                soulslike.debug("Hidden stash exists in game")

                self:TransferItems(se_stash.id)   

                local lvl = level.name()
                soulslike.debug("Added radio target to level: "..lvl)
                self.logic_state.radio_freq = math.random(30,  300)
                item_radio.add_stash(lvl, se_stash.id, self.logic_state.radio_freq) 

                local se_note = alife_create_item('soulslike_rescuers_radio_frequency_note', db.actor)

                self.game_state.note_message_data[se_note.id] = { 
                    freq = self.logic_state.radio_freq,
                    level_name = lvl
                }

                self:RespawnActor()
                return true
            else
                soulslike.debug("Hidden stash does not yet exist in game")            
                return false
            end
        end
        
        --We have to create a timer to give the game time to spawn the backpack.
        CreateTimeEvent(0, "transfer_and_respawn", 0, transfer_and_respawn)
    else    
        soulslike.debug("Hidden stash found was not created")

        self:RespawnActor()
    end
end

---------------------------------------------------------
-- Hidden Stash Scenario 
-- Hidden stash used for item drop
-- TODO: Add task to the players PDA
---------------------------------------------------------

class "HiddenStashSoulslikeScenarioLogic" (SoulslikeScenarioLogic)

function HiddenStashSoulslikeScenarioLogic:__init(state) super (state)
	self.logic_state.scenario_id = soulslike.SCENARIOS.HiddenStash
end

function HiddenStashSoulslikeScenarioLogic:CreateStash()
     -- For some reason, "box_in_same_map" doesn't actually mean same map in the treasure_manager.
    local old_box_in_same_map = treasure_manager.box_in_same_map
    treasure_manager.box_in_same_map = function(id)
        local obj1 = alife():actor()
        local obj2 = alife_object(id)
        return simulation_objects.is_on_the_same_level(obj1, obj2)
    end
    local id = treasure_manager.get_random_stash("treasure", nil ,true, true)
    treasure_manager.box_in_same_map = old_box_in_same_map

    -- If we could not grab a ransom stash, we need to return nil so we don't transfer anything
    if not id then return nil end

    debug("Random stash found: "..tostring(id))    

    local actor = db.actor
    local se_stash = alife_create("hidden_box", actor:position(), actor:level_vertex_id(), actor:game_vertex_id())

    if not self.game_state.hidden_stashes then
        self.game_state.hidden_stashes = {}
    end

    self.game_state.hidden_stashes[id] = {
        stash_id = se_stash.id,
    } 

    return se_stash
end

function HiddenStashSoulslikeScenarioLogic:HandleItemsAndRespawn() 
    local se_stash = self:CreateStash()
             
    if se_stash then
        soulslike.debug("Hidden stash found "..tostring(se_stash.id))

        local function transfer_and_respawn()
            local pack = level.object_by_id(se_stash.id)

            if pack then
                soulslike.debug("Hidden stash exists in game")

                self:TransferItems(se_stash.id)   
                level.map_add_object_spot_ser(se_stash.id, "primary_object", db.actor:character_name() .. " items")
                
                self:RespawnActor()
                return true
            else
                soulslike.debug("Hidden stash does not yet exist in game")            
                return false
            end
        end
        
        --We have to create a timer to give the game time to spawn the backpack.
        CreateTimeEvent(0, "transfer_and_respawn", 0, transfer_and_respawn)
    else    
        soulslike.debug("Hidden stash found was not created")

        self:RespawnActor()
    end
end

class "ScatteredStashesSoulslikeScenarioLogic" (SoulslikeScenarioLogic)

function ScatteredStashesSoulslikeScenarioLogic:__init(state) super (state)
	self.logic_state.scenario_id = soulslike.SCENARIOS.ScatteredStashes
end

class "NearbyDeadStalkerSoulslikeScenarioLogic" (SoulslikeScenarioLogic)

function NearbyDeadStalkerSoulslikeScenarioLogic:__init(state) super (state)
	self.logic_state.scenario_id = soulslike.SCENARIOS.NearbyDeadStalker
end

class "MutantAmbushSoulslikeScenarioLogic" (SoulslikeScenarioLogic)

function MutantAmbushSoulslikeScenarioLogic:__init(state) super (state)
	self.logic_state.scenario_id = soulslike.SCENARIOS.MutantAmbush
end

class "StalkerAmbushSoulslikeScenarioLogic" (SoulslikeScenarioLogic)

function StalkerAmbushSoulslikeScenarioLogic:__init(state) super (state)
	self.logic_state.scenario_id = soulslike.SCENARIOS.StalkerAmbush
end

function create(scenario_id, state) 
    local scenario = nil

    soulslike.debug("Creating scenario "..tostring(scenario_id))

    if scenario_id == soulslike.SCENARIOS.Default then
        scenario = soulslike_scenario_logic_factory.DefaultSoulslikeScenarioLogic(state) 
    end
    
    if scenario_id ==soulslike.SCENARIOS.RFDetectorStash then 
        scenario = soulslike_scenario_logic_factory.RFDetectorSoulslikeScenarioLogic(state) 
    end
    
    if scenario_id ==soulslike.SCENARIOS.HiddenStash then 
        scenario = soulslike_scenario_logic_factory.HiddenStashSoulslikeScenarioLogic(state) 
    end
    
    if scenario_id ==soulslike.SCENARIOS.ScatteredStashes then 
        scenario = soulslike_scenario_logic_factory.ScatteredStashesSoulslikeScenarioLogic(state) 
    end
    
    if scenario_id ==soulslike.SCENARIOS.NearbyDeadStalker then 
        scenario = soulslike_scenario_logic_factory.NearbyDeadStalkerSoulslikeScenarioLogic(state) 
    end
    
    if scenario_id ==soulslike.SCENARIOS.MutantAmbush then
         scenario = soulslike_scenario_logic_factory.MutantAmbushSoulslikeScenarioLogic(state) 
    end
    
    if scenario_id ==soulslike.SCENARIOS.StalkerAmbush then 
        scenario = soulslike_scenario_logic_factory.StalkerAmbushSoulslikeScenarioLogic(state) 
    end

    if scenario == nil then
        soulslike.debug("Unrecognized Scenario Id: "..tostring(scenario_id)) 
        scenario = soulslike_scenario_logic_factory.DefaultSoulslikeScenarioLogic(state) 
    end

    return scenario
end
