
--[[
	Jabbers
	05APR2023
	Jabbers' Soulslike Anomaly Mod
--]]


local mutant_spawns = {
    --Common Mutants
    { section = "simulation_boar",              weight = 1.00 },
    { section = "simulation_flesh",             weight = 0.90 },
    { section = "simulation_dog",               weight = 0.80 },
    { section = "zombied_sim_squad_novice",     weight = 0.70 },
    { section = "simulation_cat",               weight = 0.60 },
    { section = "simulation_boar_3_5",          weight = 0.50 },
    { section = "simulation_mix_boar_flesh",    weight = 0.40 },
    { section = "zombied_sim_squad_mix",        weight = 0.30 },
    { section = "simulation_mix_dogs",          weight = 0.20 },
    { section = "simulation_dog_5_7",           weight = 0.15 },
    { section = "simulation_pseudodog",         weight = 0.12 },
    { section = "simulation_cat_3_5",           weight = 0.10 },
    { section = "simulation_snork",             weight = 0.08 },
    --Rare Mutants
    { section = "simulation_bloodsucker",       weight = 0.04 },
    { section = "simulation_burer1",            weight = 0.03 },
    { section = "simulation_chimera",           weight = 0.02 },
    { section = "simulation_bloodsucker_2weak", weight = 0.02 },
    { section = "simulation_chimera_2weak",     weight = 0.01 },
    { section = "simulation_controller",        weight = 0.01 },
}

local stalker_spawns = {
    --Bandit
    { section = "bandit_sim_squad_novice",      community = "bandit",       weight = 1.00 },
    { section = "bandit_sim_squad_advanced",    community = "bandit",       weight = 0.50 },
    --Merc
    { section = "merc_sim_squad_novice",        community = "merc",         weight = 0.75 },
    { section = "merc_sim_squad_advanced",      community = "merc",         weight = 0.25 },
    --Duty
    { section = "duty_sim_squad_novice",        community = "duty",         weight = 1.00 },
    { section = "duty_sim_squad_advanced",      community = "duty",         weight = 0.10 },
    --Freedom
    { section = "freedom_sim_squad_novice",     community = "freedom",      weight = 1.00 },
    { section = "freedom_sim_squad_advanced",   community = "freedom",      weight = 0.10 },
    --Military
    { section = "army_sim_squad_novice",        community = "army",         weight = 1.00 },
    { section = "army_sim_squad_advanced",      community = "army",         weight = 0.10 },
    { section = "army_sim_squad_sniper",        community = "army",         weight = 0.05 },
    --Clear Sky
    { section = "csky_sim_squad_novice",        community = "csky",         weight = 1.00 },
    { section = "csky_sim_squad_advanced",      community = "csky",         weight = 0.10 },
    --Renegades
    { section = "renegade_sim_squad_novice",    community = "renegade",     weight = 0.50 },
    { section = "renegade_sim_squad_advanced",  community = "renegade",     weight = 0.20 },
}


local version = "0.20-beta"

local tools_list = {
    ["itm_basickit"] = true,
    ["itm_advancedkit"] = true,
    ["itm_expertkit"] = true,
    ["itm_drugkit"] = true,
    ["itm_ammokit"] = true,
    ["itm_gunsmith_toolkit"] = true,
    ["itm_artefactskit"] = true,
}

local obj_to_spawn_classes = {
    -- kind
    ["AI_STL_S"]    = "NPC (Stalker)",
    ["AI_TRD_S"]    = "NPC (Stalker)",

    ["SM_KAR"]	    = "NPC (Mutant)",
    ["SM_BLOOD"]    = "NPC (Mutant)",
    ["SM_BOARW"]    = "NPC (Mutant)",
    ["SM_BURER"]    = "NPC (Mutant)",
    ["SM_CAT_S"]    = "NPC (Mutant)",
    ["SM_CHIMS"]    = "NPC (Mutant)",
    ["SM_CONTR"]    = "NPC (Mutant)",
    ["SM_DOG_S"]    = "NPC (Mutant)",
    ["SM_FLESH"]    = "NPC (Mutant)",
    ["SM_IZLOM"]    = "NPC (Mutant)",
    ["SM_GIANT"]    = "NPC (Mutant)",
    ["SM_POLTR"]    = "NPC (Mutant)",
    ["SM_P_DOG"]    = "NPC (Mutant)",
    ["SM_DOG_P"]    = "NPC (Mutant)",
    ["SM_DOG_F"]    = "NPC (Mutant)",
    ["SM_SNORK"]    = "NPC (Mutant)",
    ["SM_TUSHK"]    = "NPC (Mutant)",
    ["SM_ZOMBI"]    = "NPC (Mutant)",
    ["SM_RAT"]	    = "NPC (Mutant)",
    ["SM_KARLIK"]	= "NPC (Mutant)",
    ["SM_LURKER"]	= "NPC (Mutant)",
    ["SM_PSYSUCKER"]	= "NPC (Mutant)",

    ["C_HLCP_S"] 	= "Vehicles",
    ["C_NIVA"] 		= "Vehicles",
    ["SCRPTCAR"] 	= "Vehicles",

    ["ON_OFF_S"]    = "Squads",
    
    ["O_PHYSIC"]    = "Physic (Misc.)",
    ["O_DSTRBL"]    = "Physic (Misc.)",
    ["P_DSTRBL"]    = "Physic (Misc.)",
    ["O_PHYS_S"]    = "Physic (Misc.)",
    ["O_DSTR_S"]    = "Physic (Misc.)",
    ["S_INVBOX"]    = "Physic (Misc.)",
    ["O_INVBOX"]    = "Physic (Misc.)",
    ["S_EXPLO"]     = "Physic (Misc.)",
    ["II_EXPLO"]    = "Physic (Misc.)",

    ["ZS_MBALD"]    = "Anomaly",
    ["ZS_GALAN"]    = "Anomaly",
    ["ZS_MINCE"]    = "Anomaly",
    ["ZS_RADIO"]    = "Anomaly",
    ["ZS_TORRD"]    = "Anomaly",
    ["ZS_NGRAV"]    = "Anomaly",
    ["Z_MBALD"]     = "Anomaly",
    ["Z_RADIO"]     = "Anomaly",
    ["Z_CFIRE"]     = "Anomaly",
    ["Z_NOGRAV"]    = "Anomaly",
    ["Z_TORRID"]    = "Anomaly",
    ["Z_RUSTYH"]    = "Anomaly",
    ["ZS_BFUZZ"]    = "Anomaly",
    ["ZS_AMEBA"]    = "Anomaly",
    
    ["AI_PHANT"]    = "Phantom",
}

local relations = { 
    FRIENDS = 1000,    
    BUDDIES = 500,
    NEUTRALS = 0,
    ENEMIES = -1000
}

SCENARIOS = {
    Default = 1,
    RFDetectorStash = 2,
    HiddenStash = 3,
    ScatteredStashes = 4,
    NearbyDeadStalker = 5,
    MutantAmbush = 6,
    StalkerAmbush = 7,
}

local scenario_logic = nil

----------------------------------------
-- Helpers
----------------------------------------

function math.clamp(x, min, max)
    if x < min then return min end
    if x > max then return max end
    return x
end

function table.get_length(T)
    local count = 0
    for _ in pairs(T) do count = count + 1 end
    return count
end

function table.has_value(tab, val)
    for _, value in ipairs(tab) do
        if value == val then
            return true
        end
    end    
    return false
end

----------------------------------------
-- DEBUG
----------------------------------------

local function print_table (tbl, indent)
    if not indent then
        indent = 0
    end

    utils_data.debug_write(string.rep(" ", indent) .. "{")

    indent = indent + 2

    if (type(tbl) == "userdata") then        
        utils_data.debug_write("<userdata>,\n")
    else
        for k, v in pairs(tbl) do
            local toprint = string.rep(" ", indent)

            if (type(k) == "number") then
                toprint = toprint .. "[" .. k .. "] = "
            elseif (type(k) == "string") then
                toprint = toprint  .. k ..  " = "
            end

            if (type(v) == "number") then
                utils_data.debug_write(toprint .. v .. ",")
            elseif (type(v) == "string") then
                utils_data.debug_write(toprint .. "\"" .. v .. "\",")
            elseif (type(v) == "table") then
                utils_data.debug_write(toprint)
                print_table(v, indent + 2)
            else
                utils_data.debug_write(toprint .. "\"" .. tostring(v) .. "\",")
            end
        end
    end

    utils_data.debug_write(string.rep(" ", indent-2) .. "}")
end

function debug(output)
    if not output then
        utils_data.debug_write("[Soulslike] ".."(nil)")
    end
    if (type(output) == "table") then
        utils_data.debug_write("[Soulslike] ")
        print_table(output)
    else
        utils_data.debug_write("[Soulslike] "..output)
    end
end

----------------------------------------
-- Globals
----------------------------------------

function _G.IsSoulslikeMode()
	return not IsHardcoreMode() and axr_main.config and axr_main.config:r_value("character_creation","new_game_soulslike_mode",1) == true or alife_storage_manager.get_state().enable_soulslike_mode == true
end

function _G.IsToolkit(o, s)
    if not (s) then
		s = o and o:section()
	end
    return tools_list[s]
end

----------------------------------------
-- Helper Functions
----------------------------------------

function get_soulslike_state()
    local game_state = alife_storage_manager.get_state()
    
    if not game_state.soulslike then 
        game_state.soulslike = {
            created_stashes = {},
            spawn_location = {
                    level = nil,
                    position = {
                        x = nil,
                        y = nil,
                        z = nil,
                    },
                    angle = {
                        x = nil,
                        y = nil,
                        z = nil,
                    },
                    level_vertex_id = nil,
                    game_vertex_id = nil,
                },
            note_message_data = {},
            hidden_stashes = {}
        }
    end

    return game_state.soulslike
end

function set_spawn(show_message)
	local se_actor = alife():actor()
    local state = get_soulslike_state()

	state.spawn_location.level = level.name()
	state.spawn_location.position.x = se_actor.position.x
	state.spawn_location.position.y = se_actor.position.y
	state.spawn_location.position.z = se_actor.position.z
	state.spawn_location.angle.x = se_actor.angle.x
	state.spawn_location.angle.y = se_actor.angle.y
	state.spawn_location.angle.z = se_actor.angle.z
	state.spawn_location.level_vertex_id = se_actor.m_level_vertex_id
	state.spawn_location.game_vertex_id = se_actor.m_game_vertex_id
    
    debug("Saved spawn location data:")
    debug(state)    
            
    if show_message then
        local str = game.translate_string("st_soulslike_spawn_location_set")
        actor_menu.set_msg(1, str, 4)
    end
end

function find_closest_enemy()
    local enemy = nil
    local enemy_dist = 100000
    
	for i=1, #db.OnlineStalkers do
		local id = db.OnlineStalkers[i]
		local npc = db.storage[id] and db.storage[id].object or level.object_by_id(id)
        
        if npc then
            local is_enemy = npc:general_goodwill(db.actor) <= relations.ENEMIES
            local dist = npc:position():distance_to_sqr(npc:position())

            if npc:alive() and  is_enemy and (not get_object_story_id(id)) and enemy_dist > dist then
                local comm = npc:character_community()
                debug("Found enemy "..npc:name().." from the "..comm.." community "..tostring(dist).." meters away.")
                enemy = npc
            end
        end
    end

    return enemy
end

function find_closest_friendly()  
    local friend = nil
    local friend_dist = 100000

	for i=1, #db.OnlineStalkers do
		local id = db.OnlineStalkers[i]
		local npc = db.storage[id] and db.storage[id].object or level.object_by_id(id)

        if npc then
            local dist = npc:position():distance_to_sqr(npc:position())
            local is_friend = npc:general_goodwill(db.actor) >= relations.NEUTRALS
            
            if npc:alive() and is_friend and friend_dist > dist (not get_object_story_id(id)) then
                local comm = npc:character_community()
                debug("Found friend "..friend:name().." from the "..comm.." community "..tostring(dist).." meters away.")
                friend = npc
                friend_dist = dist
                break
            end
        end
    end

    return friend
end

function force_save(type)
	--if game isn't already paused, then force a pause here
	local force_pause
	if not (device():is_paused()) then 
		device():pause(true)
		force_pause = true
	end
	local Y, M, D, h
    Y, M, D, h = game.get_game_time():get(Y, M, D, h)
    
    local m = level.get_time_minutes()
    if m < 10 then
        m = ("0"..m)
    end
    
    local comm = utils_xml.get_special_txt(db.actor:character_community())
    local map = utils_xml.get_special_txt(level.name())
    local date = string.format("%d.%d.%d %d-%d", D, M, Y, h, m)
    local file_name = "soulslike_"..comm.." - "..map.." "..date.." - "..type

	exec_console_cmd("save ".. file_name)
    
	if (force_pause) then 
		device():pause(false)
	end
end

----------------------------------------
-- Dream Callbacks
----------------------------------------

function wakeup_callback()
    debug("wakeup_callback")
	xr_effects.enable_ui(db.actor, nil)

	exec_console_cmd("snd_volume_music "..tostring(_G.mus_vol))
	exec_console_cmd("snd_volume_eff "..tostring(_G.amb_vol))

	_G.amb_vol = 0
	_G.mus_vol = 0

	disable_info("tutorial_sleep")
	disable_info("actor_is_sleeping")
	disable_info("sleep_active")
    
    debug("Looking for scenario logic.")

    if scenario_logic then
        debug("Completing scenario.")
        scenario_logic:OnComplete()  
            
        local section = "simulation_controller_psy"
        local class = ini_sys:r_string_ex(section,"class")
        local kind = ini_sys:r_string_ex(section,"kind") -- special class name for the sake of correct listing
        if kind then class = kind end

        if scenario_logic.logic_state.death_location.position.x then
            local pos = vector():set(
                scenario_logic.logic_state.death_location.position.x, 
                scenario_logic.logic_state.death_location.position.y, 
                scenario_logic.logic_state.death_location.position.z)   
            local lvid = scenario_logic.logic_state.death_location.level_vertex_id
            local gvid = scenario_logic.logic_state.death_location.game_vertex_id
            local group = obj_to_spawn_classes[class]

            local prop = {}
            local is_squad = string.find(group,"Squad")
            local cant_spawn_actor = string.find(group,"NPC") or string.find(group,"Physic")

            if (is_squad) then
                prop.no_id           = true
                prop.squad           = true
            elseif (cant_spawn_actor) then
                prop.no_id           = true
            end


            local se_obj = section and alife_create(section, pos, lvid, gvid)
            if se_obj then
                if (prop.squad) then
                    se_obj:create_npc(nil, pos, lvid, gvid)
                    local sim = alife()
                    for k in se_obj:squad_members() do
                        local se_npc = k.object or k.id and sim:object(k.id)
                        if (se_npc) then
                            level.map_add_object_spot_ser(se_npc.id, "secondary_task_location", 'Uh Oh!') 
                            SIMBOARD:setup_squad_and_group(se_npc)
                            SendScriptCallback("squad_on_npc_creation", se_obj, se_npc)
                        end 
                    end

                    debug(strformat("Spawned squad [%s] (%s)", section, se_obj.id))
                            
                else
                    level.map_add_object_spot_ser(se_obj.id, "secondary_task_location", 'Uh Oh!') 
                    debug(strformat("Spawned object [%s] (%s)", section, se_obj.id))
                end
            else
                debug(strformat("No server object made for [%s]", section))
            end
                    
        else
            debug("No nearby smarts, to dumb")
        end
    else
        debug("No logic state")

    end
    
    local data = get_soulslike_state()  
    scenario_logic:destroy()
    scenario_logic = nil    
    data.logic_state = nil
end

function dream_callback()
    debug("dream_callback")
    level.add_cam_effector("camera_effects\\sleep.anm", 10, false, "soulslike.wakeup_callback")
	
	local hours = math.random(6,14)	
	level.change_game_time(0,hours,0)
	
	db.actor.power = 1
	
	SendScriptCallback("actor_on_sleep", hours)
end

----------------------------------------
-- Game Callbacks
----------------------------------------

local function actor_on_before_death(who, flags)    
    if not IsSoulslikeMode() then
        return
    end

    -- Pretty sure this fixes arena fights, still need to test
	if has_alife_info("bar_arena_fight") then
        debug('Actor was in an arena fight, ignoring death.')
		return
	end

    debug('Actor died')
	game_statistics.increment_statistic("deaths")
	    
    debug("Looking for player backpack")
    local has_backpack = false
    local function find_backpack(_, item)
        local sec = item:section()
        has_backpack = has_backpack or (item and SYS_GetParam(0, sec, "kind") == "i_backpack")
    end
    db.actor:iterate_inventory(find_backpack)

    local player_is_indoor = not level_weathers.valid_levels[level.name()]
    
    soulslike.debug("has_backpack="..tostring(has_backpack))
    soulslike.debug("player_is_indoor="..tostring(player_is_indoor))

    local scenario_count = 0
    local scenario_weights = {}

    

    -- We want to be able to debug each scenario using the 
    -- scenario weight to max, and in this case we want to 
    -- be able to remove the default scenario so its always
    -- chosen.

    if has_backpack and not soulslike_mcm.debug_remove_default_scenario() then
        soulslike.debug("Adding default scenario")
        scenario_count = scenario_count + 1
        scenario_weights[SCENARIOS.Default] = {
            min = 0,
            max = 0,
            weight = 1.0,
        }
    end

    if not player_is_indoor and soulslike_mcm.rf_detector_scenario_weight() > 0 then
        soulslike.debug("Adding RF detector scenario")
        scenario_count = scenario_count + 1
        scenario_weights[SCENARIOS.RFDetectorStash] = {
            min = 0,
            max = 0,
            weight = soulslike_mcm.rf_detector_scenario_weight()
        }
    end
    
    if not player_is_indoor and soulslike_mcm.hidden_stash_scenario_weight() > 0 then
        soulslike.debug("Adding hidden stash scenario")
        scenario_count = scenario_count + 1
        scenario_weights[SCENARIOS.HiddenStash] = {
            min = 0,
            max = 0,
            weight = soulslike_mcm.hidden_stash_scenario_weight()
        }
    end
    
    if not player_is_indoor and soulslike_mcm.scattered_stash_scenario_weight() > 0 then
        soulslike.debug("Adding scattered stash scenario")
        scenario_count = scenario_count + 1
        scenario_weights[SCENARIOS.ScatteredStashes] = {
            min = 0,
            max = 0,
            weight = soulslike_mcm.scattered_stash_scenario_weight()
        }
    end

    -- if not player_is_indoor and soulslike_mcm.nearby_dead_stalker_scenario_weight() > 0 then
    --     scenario_count = scenario_count + 1
    --     scenario_weights[SCENARIOS.NearbyDeadStalker] = {
    --         min = 0,
    --         max = 0,
    --         weight = soulslike_mcm.nearby_dead_stalker_scenario_weight()
    --     }
    -- end

    -- if not player_is_indoor and soulslike_mcm.mutant_ambush_scenario_weight() > 0 then
    --     scenario_count = scenario_count + 1
    --     scenario_weights[SCENARIOS.MutantAmbush] = {
    --         min = 0,
    --         max = 0,
    --         weight = soulslike_mcm.mutant_ambush_scenario_weight()
    --     }
    -- end
    
    -- if not player_is_indoor and soulslike_mcm.stalker_ambush_scenario_weight() > 0 then
    --     scenario_count = scenario_count + 1
    --     scenario_weights[SCENARIOS.StalkerAmbush] = {
    --         min = 0,
    --         max = 0,
    --         weight = soulslike_mcm.stalker_ambush_scenario_weight() 
    --     }
    -- end

    -- If for some reason the player doesn't have a backpack... 
    -- and we have no other valid scenario in the list...
    -- Let's make the exception to use the Default Scenario.
    if not has_backpack and scenario_count == 0 then
        soulslike.debug("No backpack or scenarios detected.  Adding default.")
        scenario_count = scenario_count + 1
        scenario_weights[SCENARIOS.Default] = {
            min = 0,
            max = 0,
            weight = 1.0,
        }
    end

    if scenario_count == 0 then
        debug("ERROR: No scenario chosen because all scenario weights are at 0 and remove default was enabled.")
        return
    end

    local weight_sum = 0
    for _, value in pairs(scenario_weights) do
        weight_sum = weight_sum + value.weight
    end

    local min = 0
    for _, value in pairs(scenario_weights) do
        value.min = min + 1
        value.max = math.floor(min + (100 * (value.weight / weight_sum)))
        min = value.max
    end
    
    soulslike.debug(scenario_weights)

    local roll = math.random(1, 100)    
    local scenario_id = nil
    for id, value in pairs(scenario_weights) do
        if(roll >= value.min and roll <= value.max) then
            scenario_id = id
            break
        end
    end

    if scenario_id == nil then
        debug("ERROR: Unable to determine scenario from roll: "..tostring(roll))
        debug(scenario_weights)  
        scenario_id = SCENARIOS.Default
    end

    scenario_logic = soulslike_scenario_logic_factory.create(scenario_id)
    scenario_logic:OnDeath()

	flags.ret_value = false
end

local function on_before_save_input(flags, type, text)
    if not IsSoulslikeMode() then
        return
    end    

    -- No hardcore save setting, allow saving
    if not soulslike_mcm.is_hardcore_save_enabled() then 
        return
    end

    -- Hardcore save is enabled, but we still want to save at campfires
    -- We just return to let the regular saving work.
    if soulslike_mcm.override_campfire_hardcore_saves() then        
        return
    end
    
    -- All other scenarios flow through here and we just disallow saving
    if not level_weathers.valid_levels[level.name()] then
        return
    end

    debug('User tried to save')

    local str = game.translate_string("st_save_only_when_sleeping")
    actor_menu.set_msg(1, str, 4)
    exec_console_cmd("main_menu off")
    flags.ret = true
end

local function try_send_inventory_examined_message(stash_id)        
    local data = get_soulslike_state()
    local stash_data = data.created_stashes[stash_id]

    if stash_data and not stash_data.examine then        
        debug('Stash not yet examined.')
        local lost_items = stash_data.lost_items

        debug(lost_items)

        if #lost_items > 0 then

            local msg = "You examine your belongings and find that you were missing the following items: "
            local item_groups = {}
            
            for _, sec in pairs(lost_items) do
                if not item_groups[sec] then 
                    item_groups[sec] = {
                        section = sec,
                        count = 1
                    }
                else
                    item_groups[sec].count = item_groups[sec].count + 1
                end
            end

            local item_names = {}
            
            for _, group in pairs(item_groups) do
                local inv_name = ui_item.get_sec_name(group.section)
                if group.count > 1 then
                    table.insert(item_names, tostring(group.count).." x "..inv_name)                    
                else
                    table.insert(item_names, inv_name)                    
                end
            end
            
            msg = msg..table.concat(item_names, ", ")

            local ui_sender = news_manager.tips_icons['default']
            db.actor:give_game_news("", msg, ui_sender, 0, 20000)
            
            stash_data.examine = true
        end
    end
end

local function actor_on_item_take_from_box(box,obj)
    if not IsSoulslikeMode() then
        return
    end

    local data = get_soulslike_state()
    local id = box:id()

    debug('Player opened stash id '..tostring(id))
    
	if (box:section() == "inv_backpack") then
        if (box:is_inv_box_empty()) then
            hide_hud_inventory()
            
            local se_obj = alife_object(id)

            if se_obj then
                alife_release(se_obj)
                try_send_inventory_examined_message(id)
                data.created_stashes[id] = nil
            end
        end
	end
end

local function actor_on_stash_remove(data)
    if not IsSoulslikeMode() then
        return
    end

    local data = get_soulslike_state()

    if data.created_stashes[data.stash_id] then
        data.cancel = true    
        try_send_inventory_examined_message(data.stash_id)
    end
end

local function on_console_execute(name, ...)
    if not IsSoulslikeMode() then
        return
    end

    if(name == "save") then
        debug(name)
        local extraArgs = {...}

        if extraArgs then
            local last_save_file_name = table.concat(extraArgs," ")
            debug(last_save_file_name)
            if soulslike_mcm.is_hardcore_save_enabled() then
                last_save_file_name = string.lower(last_save_file_name)
            
                debug("Don't delete: ".. last_save_file_name)
            
                local uuid = get_soulslike_state().uuid	
                local fs = getFS()
                local flist = fs:file_list_open_ex("$game_saves$",bit_or(FS.FS_ListFiles,FS.FS_RootOnly),"*.scoc")
                local f_cnt = flist:Size()
            
                for	it=0, f_cnt-1 	do
                    local file = flist:GetAt(it)
                    local file_name = string.sub(file:NameFull(), 0, (string.len(file:NameFull()) - string.len(".scoc")))
                    
                    local scoc_path = fs:update_path('$game_saves$', '')..file_name..".scoc"
                    local scop_path = fs:update_path('$game_saves$', '')..file_name..".scop"
                    local dds_path = fs:update_path('$game_saves$', '')..file_name..".dds"
            
                    local f = io.open(scoc_path,"rb")
            
                    if f then
                        local data = f:read("*all")
                        f:close()
            
                        if (data) then
                            local decoded = alife_storage_manager.decode(data)
                            local d_soulslike = decoded and decoded.soulslike
                            
                            if (d_soulslike and (d_soulslike.uuid == uuid)) then
                                debug("/ Soulslike mode | file: "..file_name)
                                file_name = string.lower(file_name)
                                if file_name ~= last_save_file_name then
                                    debug("~ Soulslike mode | delete save file: "..file_name)
            
                                    local scoc_path_bak = fs:update_path('$game_saves$', '').."soulslike-backup/"..file_name..".scoc"
                                    local scop_path_bak = fs:update_path('$game_saves$', '').."soulslike-backup/"..file_name..".scop"
                                    local dds_path_bak = fs:update_path('$game_saves$', '').."soulslike-backup/"..file_name..".dds"
            
                                    fs:file_copy(scoc_path, scoc_path_bak)
                                    fs:file_copy(scop_path, scop_path_bak)
                                    fs:file_copy(dds_path, dds_path_bak)
            
                                    ui_load_dialog.delete_save_game(file_name)			
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

local function physic_object_on_use_callback(box, who)
    local data = get_soulslike_state()

    if not IsInvbox(box) or not data.hidden_stashes or not data.hidden_stashes[box:id()] then
        return
    end

    local id = box:id()
    local stash_data = data.hidden_stashes[id]
    local stash_id = stash_data.stash_id
    local stash = level.object_by_id(stash_id)

    if not stash then        
        debug("Not expected, unable to find stash id linked to Invbox.. ")
    end

    local function transfer_item(temp,item)
        debug("Transfering item "..item:section())    
        stash:transfer_item(item, box)
    end

    if stash_data.radio_id then
	    item_radio.clear_stash(stash_data.radio_id) 
    end 

	item_radio.clear_stash(stash_data.stash_id) 

    debug("Transfering items from hidden stash "..tostring(id).." to static stash "..tostring(stash_id))    
    stash:iterate_inventory_box(transfer_item)      
    alife_release(stash)

    debug("Removing PDA marker "..tostring(id))   
    level.map_remove_object_spot(id , "secondary_task_location")

    data.hidden_stashes[id] = nil
end

local function load_state(data) 
    if not IsSoulslikeMode() then
        return
    end

    local data = get_soulslike_state()

    if data.logic_state then
        -- Reinitialize the last scenario using the saved logic state.
        scenario_logic = soulslike_scenario_logic_factory.create(data.logic_state.scenario_id, data.logic_state)
    end
end

local function save_state(data) 
    if not IsSoulslikeMode() then
        return
    end

    local data = get_soulslike_state()

    if not data.spawn_location.level and level.name() ~= 'fake_start' then
        set_spawn(false)
    end

    if scenario_logic then
        -- Save the logic state for the current scenario so we can restore it on load
        -- This is for the purposes of ChangeLevel which unloads the scripts and then 
        -- reloads them, so we need to be able to reinitialize the scenario as it was
        -- before changing levels
        data.logic_state = scenario_logic.logic_state;
    end
end

local function on_level_changing() 
    if not IsSoulslikeMode() then
        return
    end

    debug("On on_level_changing load.")
    local data = get_soulslike_state()

    if not data.spawn_location.level and level.name() ~= 'fake_start' then
        set_spawn(false)
    end
end

local function on_game_load()
    if not IsSoulslikeMode() then
        return
    end

    debug("On game load.")

    local data = get_soulslike_state()

    -- Write out an identifier so we can use it later
    -- to identify other saves with the same ID if the 
    -- user is playing with Hardcore Saves enabled.
    if not data.uuid then        
        data.uuid = GAME_VERSION .. "_" .. tostring(math.random(100)) .. tostring(math.random()) .. tostring(math.random(1000))
    end

    debug("Looking for scenario logic.")

    if scenario_logic then
        debug("Calling scenario respawn.")
        scenario_logic:OnRespawn()
    end
end 

local function actor_on_sleep(hours)    
    if not IsSoulslikeMode() then
        return
    end

    soulslike.debug('actor_on_sleep')

    -- Only force save if we aren't running a scenario 
    if not scenario_logic then
        soulslike.force_save("sleep")
    end
end

local dtype = {
	[hit.light_burn]    = "light_burn",
	[hit.burn]          = "burn",
	[hit.strike]        = "strike",
	[hit.shock]         = "shock",
	[hit.wound]         = "wound",
	[hit.radiation]     = "radiation",
	[hit.telepatic]     = "telepatic",
	[hit.chemical_burn] = "chemical_burn",
	[hit.explosion]     = "explosion",
	[hit.fire_wound]    = "fire_wound",
}

local hit_pool = {

}

local function actor_on_before_hit(shit,bone_id,flags)
    debug("Player hit:")
    debug("shit.type: "..tostring(dtype[shit.type]))
    debug("shit.power: "..tostring(shit.power))
    debug("shit.impulse: "..tostring(shit.impulse))
    debug("shit.draftsman: "..(shit and shit.draftsman:name() or "<nil>"))

    local is_stalker = false
    local is_monster = false
    local is_anomaly = false

    if shit.draftsman then
        is_stalker = IsStalker(shit.draftsman)
        is_monster = IsMonster(shit.draftsman)
        is_anomaly = IsAnomaly(shit.draftsman)
        debug("shit.draftsman: "..(shit and shit.draftsman:name() or "<nil>"))
    end

    local health = db.actor.health
    local is_fatal = shit.power >= health

    table.insert(hit_pool, { 
        time = time_global(),
        hit_type = shit.type,
        hit_power = shit.power,
        draftsman_id = shit.draftsman and shit.draftsman:id() or nil,
        is_stalker = is_stalker,
        is_monster = is_monster,
        is_anomaly = is_anomaly,
    }

    debug("is_fatal: "..tostring(is_fatal))
end

function on_game_start()
    debug('Version: '..version)

    RegisterScriptCallback("actor_on_stash_remove", actor_on_stash_remove)
    RegisterScriptCallback("actor_on_item_take_from_box", actor_on_item_take_from_box)
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
    RegisterScriptCallback("on_before_save_input", on_before_save_input)
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("on_level_changing", on_level_changing)
    RegisterScriptCallback("on_game_load", on_game_load)
    RegisterScriptCallback("actor_on_sleep", actor_on_sleep)
	RegisterScriptCallback("on_console_execute", on_console_execute)
    RegisterScriptCallback("actor_on_before_hit", actor_on_before_hit)
	RegisterScriptCallback("physic_object_on_use_callback", physic_object_on_use_callback)
end
