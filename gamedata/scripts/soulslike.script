
--[[
	Jabbers
	05APR2023
	Jabbers' Soulslike Anomaly Mod
--]]

local version = "0.16-beta"

local tools_list = {
    ["itm_basickit"] = true,
    ["itm_advancedkit"] = true,
    ["itm_expertkit"] = true,
    ["itm_drugkit"] = true,
    ["itm_ammokit"] = true,
    ["itm_gunsmith_toolkit"] = true,
    ["itm_artefactskit"] = true,
}

local relations = { 
    FRIENDS = 1000,    
    BUDDIES = 500,
    NEUTRALS = 0,
    ENEMIES = -1000
}

SCENARIOS = {
    Default = 1,
    RFDetectorStash = 2,
    HiddenStash = 3,
    ScatteredStashes = 4,
    NearbyDeadStalker = 5,
    MutantAmbush = 6,
    StalkerAmbush = 7,
}

local SCENARIO_COUNT = 7

----------------------------------------
-- Helpers
----------------------------------------

function math.clamp(x, min, max)
    if x < min then return min end
    if x > max then return max end
    return x
end

----------------------------------------
-- DEBUG
----------------------------------------

local function print_table (tbl, indent)
    if not indent then
        indent = 0
    end

    utils_data.debug_write(string.rep(" ", indent) .. "{")

    indent = indent + 2

    if (type(tbl) == "userdata") then        
        utils_data.debug_write("<userdata>,\n")
    else
        for k, v in pairs(tbl) do
            local toprint = string.rep(" ", indent)

            if (type(k) == "number") then
                toprint = toprint .. "[" .. k .. "] = "
            elseif (type(k) == "string") then
                toprint = toprint  .. k ..  " = "
            end

            if (type(v) == "number") then
                utils_data.debug_write(toprint .. v .. ",")
            elseif (type(v) == "string") then
                utils_data.debug_write(toprint .. "\"" .. v .. "\",")
            elseif (type(v) == "table") then
                utils_data.debug_write(toprint)
                print_table(v, indent + 2)
            else
                utils_data.debug_write(toprint .. "\"" .. tostring(v) .. "\",")
            end
        end
    end

    utils_data.debug_write(string.rep(" ", indent-2) .. "}")
end

function debug(output)
    if not output then
        utils_data.debug_write("[Soulslike] ".."(nil)")
    end
    if (type(output) == "table") then
        utils_data.debug_write("[Soulslike] ")
        print_table(output)
    else
        utils_data.debug_write("[Soulslike] "..output)
    end
end

function IsSoulslikeMode()
	return not IsHardcoreMode() and axr_main.config and axr_main.config:r_value("character_creation","new_game_soulslike_mode",1) == true or alife_storage_manager.get_state().enable_soulslike_mode == true
end

function get_soulslike_state()
    local game_state = alife_storage_manager.get_state().soulslike or {
        created_stashes = {}
    }

    return game_state
end

function set_spawn(show_message)
	local se_actor = alife():actor()

    local state = get_soulslike_state()

	state.spawn_location.level = level.name()
	state.spawn_location.position.x= se_actor.position.x
	state.spawn_location.position.y = se_actor.position.y
	state.spawn_location.position.z = se_actor.position.z
	state.spawn_location.angle.x = se_actor.angle.x
	state.spawn_location.angle.y = se_actor.angle.y
	state.spawn_location.angle.z = se_actor.angle.z
	state.spawn_location.level_vertex_id = se_actor.m_level_vertex_id
	state.spawn_location.game_vertex_id = se_actor.m_game_vertex_id
    
    debug("Saved spawn location data:")
    debug(state.spawn_location)    
            
    if show_message then
        local str = game.translate_string("st_soulslike_spawn_location_set")
        actor_menu.set_msg(1, str, 4)
    end
end

function find_enemy()
    local enemy = nil
	for i=1, #db.OnlineStalkers do
		local id = db.OnlineStalkers[i]
		enemy = level.object_by_id(id)
        if enemy then
            local is_enemy = enemy:general_goodwill(db.actor) <= relations.ENEMIES
            if enemy:alive() and   
                (not get_object_story_id(id)) and
                is_enemy then
                local comm = enemy:character_community()
                debug("Found enemy "..enemy:name().." from the "..comm.." community.")
                return enemy
            end
        end
    end
end

function find_actor_community_friendly()  
    local friend = nil
    local actor_comm = db.actor:character_community():sub(7) -- removes "actor_"

    debug("Actor community "..actor_comm)

	for i=1, #db.OnlineStalkers do
		local id = db.OnlineStalkers[i]
		friend = db.storage[id] and db.storage[id].object or level.object_by_id(id)
        if friend then
			local comm = friend:character_community()
            debug("Found friend "..friend:name().." from the "..comm.." community.")  

            if friend:alive() and   
               comm == actor_comm and
               (not get_object_story_id(id)) then
                debug("Found friend "..friend:name().." from the "..comm.." community.")
                break
            end
        else 
            friend = nil
        end
    end

    return friend
end

function IsToolkit(o, s)
    if not (s) then
		s = o and o:section()
	end
    return tools_list[s]
end

local function remove_prior_saves(last_save_file_name)    
    last_save_file_name = string.lower(last_save_file_name)

    debug("Don't delete: ".. last_save_file_name)

	local uuid = get_soulslike_state().uuid	
	local fs = getFS()
	local flist = fs:file_list_open_ex("$game_saves$",bit_or(FS.FS_ListFiles,FS.FS_RootOnly),"*.scoc")
	local f_cnt = flist:Size()

	for	it=0, f_cnt-1 	do
		local file = flist:GetAt(it)
		local file_name = string.sub(file:NameFull(), 0, (string.len(file:NameFull()) - string.len(".scoc")))
        
		local scoc_path = fs:update_path('$game_saves$', '')..file_name..".scoc"
		local scop_path = fs:update_path('$game_saves$', '')..file_name..".scop"
		local dds_path = fs:update_path('$game_saves$', '')..file_name..".dds"

		local f = io.open(scoc_path,"rb")

		if (f) then
			local data = f:read("*all")
			f:close()

			if (data) then
				local decoded = alife_storage_manager.decode(data)
				local d_soulslike = decoded and decoded.soulslike
                
				if (d_soulslike and (d_soulslike.uuid == uuid)) then
					debug("/ Soulslike mode | file: "..file_name)
                    file_name = string.lower(file_name)
					if file_name ~= last_save_file_name then
						debug("~ Soulslike mode | delete save file: "..file_name)

                        local scoc_path_bak = fs:update_path('$game_saves$', '').."soulslike-backup/"..file_name..".scoc"
                        local scop_path_bak = fs:update_path('$game_saves$', '').."soulslike-backup/"..file_name..".scop"
                        local dds_path_bak = fs:update_path('$game_saves$', '').."soulslike-backup/"..file_name..".dds"

                        fs:file_copy(scoc_path, scoc_path_bak)
                        fs:file_copy(scop_path, scop_path_bak)
                        fs:file_copy(dds_path, dds_path_bak)

						ui_load_dialog.delete_save_game(file_name)			
					end
				end
			end
		end
	end
end

function force_save(type)
	--if game isn't already paused, then force a pause here
	local force_pause
	if not (device():is_paused()) then 
		device():pause(true)
		force_pause = true
	end
	local Y, M, D, h
    Y, M, D, h = game.get_game_time():get(Y, M, D, h)
    
    local m = level.get_time_minutes()
    if m < 10 then
        m = ("0"..m)
    end
    
    local comm = utils_xml.get_special_txt(db.actor:character_community())
    local map = utils_xml.get_special_txt(level.name())
    local date = string.format("%d.%d.%d %d-%d", D, M, Y, h, m)
    local file_name = "soulslike_"..comm.." - "..map.." "..date.." - "..type

	exec_console_cmd("save ".. file_name)
    
	if (force_pause) then 
		device():pause(false)
	end
end

local function actor_on_before_death(who, flags)    
    if not IsSoulslikeMode() then
        return
    end

    -- Pretty sure this fixes arena fights, still need to test
	if has_alife_info("bar_arena_fight") then
        debug('Actor was in an arena fight, ignoring death.')
		return
	end

    debug('Actor died')

	flags.ret_value = false

    --TODO: Implement logic that checks for a backpack, if the player doesnt have a backpack always use hidden stash scenario
    
    local scenario_weights = { 
        [SCENARIOS.Default] = {
            min = 0,
            max = 0,
            weight = 1.0 / SCENARIO_COUNT,
        },
        [SCENARIOS.RFDetectorStash] = {
            min = 0,
            max = 0,
            weight = rf_detector_scenario_weight()
        },
        [SCENARIOS.HiddenStash] = {
            min = 0,
            max = 0,
            weight = hidden_stash_scenario_weight()
        },
        [SCENARIOS.ScatteredStashes] = {
            min = 0,
            max = 0,
            weight = scattered_stash_scenario_weight()
        },
        [SCENARIOS.NearbyDeadStalker] = {
            min = 0,
            max = 0,
            weight = nearby_dead_stalker_scenario_weight()
        },
        [SCENARIOS.MutantAmbush] = {
            min = 0,
            max = 0,
            weight = mutant_ambush_scenario_weight()
        },
        [SCENARIOS.StalkerAmbush] = {
            min = 0,
            max = 0,
            weight = stalker_ambush_scenario_weight() 
        },
    }

    local weight_sum = 0
    for _, value in pairs(scenario_weights) do
        weight_sum = weight_sum + value.weight
    end

    local min = 0
    for _, value in pairs(scenario_weights) do
        value.min = min + 1
        value.max = math.floor(min + (100 * (value.weight / weight_sum)))
        min = value.max
    end

    local roll = math.random(1, 100)    
    local scenario_id = nil
    for id, value in pairs(scenario_weights) do
        if(roll >= value.min and roll <= value.max) then
            scenario_id = id
            break
        end
    end

    if scenario_id == nil then
        debug("Unable to determine scenario from roll: "..tostring(roll))
        debug(scenario_weights)  
        scenario_id = SCENARIOS.Default
    end

    local scenario_logic = soulslike_scenario_logic_factory.create(scenario_id)

    scenario_logic:Initialize()
    scenario_logic:OnDeath()
end

local function on_before_save_input(flags, type, text)
    if not IsSoulslikeMode() then
        return
    end    

    -- No hardcore save setting, allow saving
    if not soulslike_mcm.is_hardcore_save_enabled() then 
        return
    end

    -- Hardcore save is enabled, but we still want to save at campfires
    -- We just return to let the regular saving work.
    if soulslike_mcm.override_campfire_hardcore_saves() then        
        return
    end
    
    -- All other scenarios flow through here and we just disallow saving
    if not level_weathers.valid_levels[level.name()] then
        return
    end

    debug('User tried to save')

    local str = game.translate_string("st_save_only_when_sleeping")
    actor_menu.set_msg(1, str, 4)
    exec_console_cmd("main_menu off")
    flags.ret = true
end

local function on_game_load()        
    if not IsSoulslikeMode() then
        return
    end

    debug('Version: '..version)

    local data = get_soulslike_state()

    -- Write out an identifier so we can use it later
    -- to identify other saves with the same ID if the 
    -- user is playing with Hardcore Saves enabled.
    if not data.uuid then        
        data.uuid = GAME_VERSION .. "_" .. tostring(math.random(100)) .. tostring(math.random()) .. tostring(math.random(1000))
    end
end

local function tablelength(T)
    local count = 0
    for _ in pairs(T) do count = count + 1 end
    return count
end

local function try_send_inventory_examined_message(stash_id)    
    local data = get_soulslike_state()
    local stash_data = data.created_stashes[stash_id]
    if stash_data and not stash_data.examine then        
        debug('Stash not yet examined.')
        local lost_items = stash_data.lost_items

        debug(lost_items)
        debug('Item lost count = '..tostring(#lost_items))
        debug('Item lost count = '..tostring(tablelength(lost_items)))

        if #lost_items > 0 then

            local msg = "You examine your belongings and find that you were missing the following items: "
            local item_groups = {}
            
            for _, sec in pairs(lost_items) do
                if not item_groups[sec] then 
                    item_groups[sec] = {
                        section = sec,
                        count = 1
                    }
                else
                    item_groups[sec].count = item_groups[sec].count + 1
                end
            end

            local item_names = {}
            
            for _, group in pairs(item_groups) do
                local inv_name = ui_item.get_sec_name(group.section)
                if group.count > 1 then
                    table.insert(item_names, tostring(group.count).." x "..inv_name)                    
                else
                    table.insert(item_names, inv_name)                    
                end
            end
            
            msg = msg..table.concat(item_names, ", ")

            local ui_sender = news_manager.tips_icons['default']
            db.actor:give_game_news("", msg, ui_sender, 0, 20000)
            
            stash_data.examine = true
        end
    end
end

local function actor_on_item_take_from_box(box,obj)
    if not IsSoulslikeMode() then
        return
    end

    local data = get_soulslike_state()
    local id = box:id()
    debug('Player opened stash id '..tostring(id))
    
	if (box:section() == "inv_backpack") then
        if (box:is_inv_box_empty()) then
            hide_hud_inventory()
            
            local se_obj = alife_object(id)

            if se_obj then
                alife_release(se_obj)
                try_send_inventory_examined_message(id)
                data.created_stashes[id] = nil
            end
        end
	end
end

local function actor_on_stash_remove(data)
    if not IsSoulslikeMode() then
        return
    end

    local data = get_soulslike_state()

    if data.created_stashes[data.stash_id] then
        data.cancel = true    
        try_send_inventory_examined_message(data.stash_id)
    end
end

local function on_console_execute(name, ...)
    if not IsSoulslikeMode() then
        return
    end

    if(name == "save") then
        debug(name)

        local extraArgs = {...}

        if extraArgs then
            local file_name = table.concat(extraArgs," ")
            debug(file_name)
            if soulslike_mcm.is_hardcore_save_enabled() then
                remove_prior_saves(file_name)
            end
        end
    end
end

local function physic_object_on_use_callback(box, who)
    local data = get_soulslike_state()

    if not IsInvbox(box) or not data.hidden_stashes or not data.hidden_stashes[box:id()] then
        return
    end

    local stash_data = data.hidden_stashes[box:id()]
    local stash_id = stash_data.stash_id
    local stash = level.object_by_id(stash_id)

    if not stash then        
        debug("Not expected, unable to find stash id linked to Invbox.. ")
    end

    local function transfer_item(temp,item)
        debug("Transfering item "..item:section())    
        stash:transfer_item(item, box)
    end

	item_radio.clear_stash(stash_data.radio_id) 
	item_radio.clear_stash(stash_data.stash_id) 

    debug("Transfering items from hidden stash to static stash.")    
    stash:iterate_inventory_box(transfer_item)      
    alife_release(stash)
    
    data.hidden_stashes[box:id()] = nil
    data.created_stashes[stash_id] = nil
end

function on_game_start()
    RegisterScriptCallback("actor_on_stash_remove", actor_on_stash_remove)
    RegisterScriptCallback("actor_on_item_take_from_box",actor_on_item_take_from_box)
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
    RegisterScriptCallback("on_before_save_input",on_before_save_input)
    RegisterScriptCallback("on_game_load",on_game_load)
	RegisterScriptCallback("on_console_execute",on_console_execute)
	RegisterScriptCallback("physic_object_on_use_callback", physic_object_on_use_callback)
end
