
--[[
	Jabbers
	05APR2023
	Jabbers' Soulslike Anomaly Mod
--]]

local version = "0.20-beta"

local tools_list = {
    ["itm_basickit"] = true,
    ["itm_advancedkit"] = true,
    ["itm_expertkit"] = true,
    ["itm_drugkit"] = true,
    ["itm_ammokit"] = true,
    ["itm_gunsmith_toolkit"] = true,
    ["itm_artefactskit"] = true,
}

local relations = { 
    FRIENDS = 1000,    
    BUDDIES = 500,
    NEUTRALS = 0,
    ENEMIES = -1000
}

SCENARIOS = {
    Default = 1,
    RFDetectorStash = 2,
    HiddenStash = 3,
    ScatteredStashes = 4,
    NearbyDeadStalker = 5,
    MutantAmbush = 6,
    StalkerAmbush = 7,
}

local scenario_logic = nil

----------------------------------------
-- Helpers
----------------------------------------

function math.clamp(x, min, max)
    if x < min then return min end
    if x > max then return max end
    return x
end

----------------------------------------
-- DEBUG
----------------------------------------

local function print_table (tbl, indent)
    if not indent then
        indent = 0
    end

    utils_data.debug_write(string.rep(" ", indent) .. "{")

    indent = indent + 2

    if (type(tbl) == "userdata") then        
        utils_data.debug_write("<userdata>,\n")
    else
        for k, v in pairs(tbl) do
            local toprint = string.rep(" ", indent)

            if (type(k) == "number") then
                toprint = toprint .. "[" .. k .. "] = "
            elseif (type(k) == "string") then
                toprint = toprint  .. k ..  " = "
            end

            if (type(v) == "number") then
                utils_data.debug_write(toprint .. v .. ",")
            elseif (type(v) == "string") then
                utils_data.debug_write(toprint .. "\"" .. v .. "\",")
            elseif (type(v) == "table") then
                utils_data.debug_write(toprint)
                print_table(v, indent + 2)
            else
                utils_data.debug_write(toprint .. "\"" .. tostring(v) .. "\",")
            end
        end
    end

    utils_data.debug_write(string.rep(" ", indent-2) .. "}")
end

function debug(output)
    if not output then
        utils_data.debug_write("[Soulslike] ".."(nil)")
    end
    if (type(output) == "table") then
        utils_data.debug_write("[Soulslike] ")
        print_table(output)
    else
        utils_data.debug_write("[Soulslike] "..output)
    end
end

function IsSoulslikeMode()
	return not IsHardcoreMode() and axr_main.config and axr_main.config:r_value("character_creation","new_game_soulslike_mode",1) == true or alife_storage_manager.get_state().enable_soulslike_mode == true
end

function get_soulslike_state()
    local game_state = alife_storage_manager.get_state()
    
    if not game_state.soulslike then 
        game_state.soulslike = {
            created_stashes = {},
            spawn_location = {
                    level = nil,
                    position = {
                        x = nil,
                        y = nil,
                        z = nil,
                    },
                    angle = {
                        x = nil,
                        y = nil,
                        z = nil,
                    },
                    level_vertex_id = nil,
                    game_vertex_id = nil,
                },
            note_message_data = {},
            hidden_stashes = {}
        }
    end

    return game_state.soulslike
end

function set_spawn(show_message)
	local se_actor = alife():actor()
    local state = get_soulslike_state()

	state.spawn_location.level = level.name()
	state.spawn_location.position.x = se_actor.position.x
	state.spawn_location.position.y = se_actor.position.y
	state.spawn_location.position.z = se_actor.position.z
	state.spawn_location.angle.x = se_actor.angle.x
	state.spawn_location.angle.y = se_actor.angle.y
	state.spawn_location.angle.z = se_actor.angle.z
	state.spawn_location.level_vertex_id = se_actor.m_level_vertex_id
	state.spawn_location.game_vertex_id = se_actor.m_game_vertex_id
    
    debug("Saved spawn location data:")
    debug(state)    
            
    if show_message then
        local str = game.translate_string("st_soulslike_spawn_location_set")
        actor_menu.set_msg(1, str, 4)
    end
end

function find_enemy()
    local enemy = nil
	for i=1, #db.OnlineStalkers do
		local id = db.OnlineStalkers[i]
		enemy = level.object_by_id(id)
        if enemy then
            local is_enemy = enemy:general_goodwill(db.actor) <= relations.ENEMIES
            if enemy:alive() and   
                (not get_object_story_id(id)) and
                is_enemy then
                local comm = enemy:character_community()
                debug("Found enemy "..enemy:name().." from the "..comm.." community.")
                return enemy
            end
        end
    end
end

function find_actor_community_friendly()  
    local friend = nil
    local actor_comm = db.actor:character_community():sub(7) -- removes "actor_"

    debug("Actor community "..actor_comm)

	for i=1, #db.OnlineStalkers do
		local id = db.OnlineStalkers[i]
		friend = db.storage[id] and db.storage[id].object or level.object_by_id(id)
        if friend then
			local comm = friend:character_community()
            debug("Found friend "..friend:name().." from the "..comm.." community.")  

            if friend:alive() and   
               comm == actor_comm and
               (not get_object_story_id(id)) then
                debug("Found friend "..friend:name().." from the "..comm.." community.")
                break
            end
        else 
            friend = nil
        end
    end

    return friend
end

function IsToolkit(o, s)
    if not (s) then
		s = o and o:section()
	end
    return tools_list[s]
end

local function remove_prior_saves(last_save_file_name)    
    last_save_file_name = string.lower(last_save_file_name)

    debug("Don't delete: ".. last_save_file_name)

	local uuid = get_soulslike_state().uuid	
	local fs = getFS()
	local flist = fs:file_list_open_ex("$game_saves$",bit_or(FS.FS_ListFiles,FS.FS_RootOnly),"*.scoc")
	local f_cnt = flist:Size()

	for	it=0, f_cnt-1 	do
		local file = flist:GetAt(it)
		local file_name = string.sub(file:NameFull(), 0, (string.len(file:NameFull()) - string.len(".scoc")))
        
		local scoc_path = fs:update_path('$game_saves$', '')..file_name..".scoc"
		local scop_path = fs:update_path('$game_saves$', '')..file_name..".scop"
		local dds_path = fs:update_path('$game_saves$', '')..file_name..".dds"

		local f = io.open(scoc_path,"rb")

		if (f) then
			local data = f:read("*all")
			f:close()

			if (data) then
				local decoded = alife_storage_manager.decode(data)
				local d_soulslike = decoded and decoded.soulslike
                
				if (d_soulslike and (d_soulslike.uuid == uuid)) then
					debug("/ Soulslike mode | file: "..file_name)
                    file_name = string.lower(file_name)
					if file_name ~= last_save_file_name then
						debug("~ Soulslike mode | delete save file: "..file_name)

                        local scoc_path_bak = fs:update_path('$game_saves$', '').."soulslike-backup/"..file_name..".scoc"
                        local scop_path_bak = fs:update_path('$game_saves$', '').."soulslike-backup/"..file_name..".scop"
                        local dds_path_bak = fs:update_path('$game_saves$', '').."soulslike-backup/"..file_name..".dds"

                        fs:file_copy(scoc_path, scoc_path_bak)
                        fs:file_copy(scop_path, scop_path_bak)
                        fs:file_copy(dds_path, dds_path_bak)

						ui_load_dialog.delete_save_game(file_name)			
					end
				end
			end
		end
	end
end

function force_save(type)
	--if game isn't already paused, then force a pause here
	local force_pause
	if not (device():is_paused()) then 
		device():pause(true)
		force_pause = true
	end
	local Y, M, D, h
    Y, M, D, h = game.get_game_time():get(Y, M, D, h)
    
    local m = level.get_time_minutes()
    if m < 10 then
        m = ("0"..m)
    end
    
    local comm = utils_xml.get_special_txt(db.actor:character_community())
    local map = utils_xml.get_special_txt(level.name())
    local date = string.format("%d.%d.%d %d-%d", D, M, Y, h, m)
    local file_name = "soulslike_"..comm.." - "..map.." "..date.." - "..type

	exec_console_cmd("save ".. file_name)
    
	if (force_pause) then 
		device():pause(false)
	end
end

function wakeup_callback()
    debug("wakeup_callback")
	xr_effects.enable_ui(db.actor, nil)

	exec_console_cmd("snd_volume_music "..tostring(_G.mus_vol))
	exec_console_cmd("snd_volume_eff "..tostring(_G.amb_vol))

	_G.amb_vol = 0
	_G.mus_vol = 0

	disable_info("tutorial_sleep")
	disable_info("actor_is_sleeping")
	disable_info("sleep_active")
    
    debug("Looking for scenario logic.")

    if scenario_logic then
        debug("Completing scenario.")
        scenario_logic:OnComplete()
        scenario_logic = nil
        local data = get_soulslike_state()    
        data.logic_state = nil
    end
end

function dream_callback()
    debug("dream_callback")
    level.add_cam_effector("camera_effects\\sleep.anm", 10, false, "soulslike.wakeup_callback")
	
	local hours = math.random(6,14)	
	level.change_game_time(0,hours,0)
	
	db.actor.power = 1
	
	SendScriptCallback("actor_on_sleep", hours)
end

local function actor_on_before_death(who, flags)    
    if not IsSoulslikeMode() then
        return
    end

    -- Pretty sure this fixes arena fights, still need to test
	if has_alife_info("bar_arena_fight") then
        debug('Actor was in an arena fight, ignoring death.')
		return
	end

    debug('Actor died')
	game_statistics.increment_statistic("deaths")
	    
    soulslike.debug("Looking for player backpack")
    local has_backpack = false
    local function find_backpack(_, item)
        local sec = item:section()
        has_backpack = has_backpack or (item and SYS_GetParam(0, sec, "kind") == "i_backpack")
    end
    db.actor:iterate_inventory(find_backpack)

    local player_is_indoor = not level_weathers.valid_levels[level.name()]
    
    soulslike.debug("has_backpack="..tostring(has_backpack))
    soulslike.debug("player_is_indoor="..tostring(player_is_indoor))

    local scenario_count = 0
    local scenario_weights = {}

    -- We want to be able to debug each scenario using the 
    -- scenario weight to max, and in this case we want to 
    -- be able to remove the default scenario so its always
    -- chosen.

    if has_backpack and not soulslike_mcm.debug_remove_default_scenario() then
        soulslike.debug("Adding default scenario")
        scenario_count = scenario_count + 1
        scenario_weights[SCENARIOS.Default] = {
            min = 0,
            max = 0,
            weight = 1.0,
        }
    end

    if not player_is_indoor and soulslike_mcm.rf_detector_scenario_weight() > 0 then
        soulslike.debug("Adding RF detector scenario")
        scenario_count = scenario_count + 1
        scenario_weights[SCENARIOS.RFDetectorStash] = {
            min = 0,
            max = 0,
            weight = soulslike_mcm.rf_detector_scenario_weight()
        }
    end
    
    if not player_is_indoor and soulslike_mcm.hidden_stash_scenario_weight() > 0 then
        soulslike.debug("Adding hidden stash scenario")
        scenario_count = scenario_count + 1
        scenario_weights[SCENARIOS.HiddenStash] = {
            min = 0,
            max = 0,
            weight = soulslike_mcm.hidden_stash_scenario_weight()
        }
    end
    
    if not player_is_indoor and soulslike_mcm.scattered_stash_scenario_weight() > 0 then
        soulslike.debug("Adding scattered stash scenario")
        scenario_count = scenario_count + 1
        scenario_weights[SCENARIOS.ScatteredStashes] = {
            min = 0,
            max = 0,
            weight = soulslike_mcm.scattered_stash_scenario_weight()
        }
    end

    -- if not player_is_indoor and soulslike_mcm.nearby_dead_stalker_scenario_weight() > 0 then
    --     scenario_count = scenario_count + 1
    --     scenario_weights[SCENARIOS.NearbyDeadStalker] = {
    --         min = 0,
    --         max = 0,
    --         weight = soulslike_mcm.nearby_dead_stalker_scenario_weight()
    --     }
    -- end

    -- if not player_is_indoor and soulslike_mcm.mutant_ambush_scenario_weight() > 0 then
    --     scenario_count = scenario_count + 1
    --     scenario_weights[SCENARIOS.MutantAmbush] = {
    --         min = 0,
    --         max = 0,
    --         weight = soulslike_mcm.mutant_ambush_scenario_weight()
    --     }
    -- end
    
    -- if not player_is_indoor and soulslike_mcm.stalker_ambush_scenario_weight() > 0 then
    --     scenario_count = scenario_count + 1
    --     scenario_weights[SCENARIOS.StalkerAmbush] = {
    --         min = 0,
    --         max = 0,
    --         weight = soulslike_mcm.stalker_ambush_scenario_weight() 
    --     }
    -- end

    -- If for some reason the player doesn't have a backpack... 
    -- and we have no other valid scenario in the list...
    -- Let's make the exception to use the Default Scenario.
    if not has_backpack and scenario_count == 0 then
        soulslike.debug("No backpack or scenarios detected.  Adding default.")
        scenario_count = scenario_count + 1
        scenario_weights[SCENARIOS.Default] = {
            min = 0,
            max = 0,
            weight = 1.0,
        }
    end

    if scenario_count == 0 then
        debug("ERROR: No scenario chosen because all scenario weights are at 0 and remove default was enabled.")
        return
    end

    local weight_sum = 0
    for _, value in pairs(scenario_weights) do
        weight_sum = weight_sum + value.weight
    end

    local min = 0
    for _, value in pairs(scenario_weights) do
        value.min = min + 1
        value.max = math.floor(min + (100 * (value.weight / weight_sum)))
        min = value.max
    end
    
    soulslike.debug(scenario_weights)

    local roll = math.random(1, 100)    
    local scenario_id = nil
    for id, value in pairs(scenario_weights) do
        if(roll >= value.min and roll <= value.max) then
            scenario_id = id
            break
        end
    end

    if scenario_id == nil then
        debug("ERROR: Unable to determine scenario from roll: "..tostring(roll))
        debug(scenario_weights)  
        scenario_id = SCENARIOS.Default
    end

    scenario_logic = soulslike_scenario_logic_factory.create(scenario_id)
    scenario_logic:OnDeath()

	flags.ret_value = false
end

local function on_before_save_input(flags, type, text)
    if not IsSoulslikeMode() then
        return
    end    

    -- No hardcore save setting, allow saving
    if not soulslike_mcm.is_hardcore_save_enabled() then 
        return
    end

    -- Hardcore save is enabled, but we still want to save at campfires
    -- We just return to let the regular saving work.
    if soulslike_mcm.override_campfire_hardcore_saves() then        
        return
    end
    
    -- All other scenarios flow through here and we just disallow saving
    if not level_weathers.valid_levels[level.name()] then
        return
    end

    debug('User tried to save')

    local str = game.translate_string("st_save_only_when_sleeping")
    actor_menu.set_msg(1, str, 4)
    exec_console_cmd("main_menu off")
    flags.ret = true
end

function tablelength(T)
    local count = 0
    for _ in pairs(T) do count = count + 1 end
    return count
end

function tableHasValue(tab, val)
    for _, value in ipairs(tab) do
        if value == val then
            return true
        end
    end    
    return false
end

local function try_send_inventory_examined_message(stash_id)        
    local data = get_soulslike_state()
    local stash_data = data.created_stashes[stash_id]

    if stash_data and not stash_data.examine then        
        debug('Stash not yet examined.')
        local lost_items = stash_data.lost_items

        debug(lost_items)
        debug('Item lost count = '..tostring(#lost_items))
        debug('Item lost count = '..tostring(tablelength(lost_items)))

        if #lost_items > 0 then

            local msg = "You examine your belongings and find that you were missing the following items: "
            local item_groups = {}
            
            for _, sec in pairs(lost_items) do
                if not item_groups[sec] then 
                    item_groups[sec] = {
                        section = sec,
                        count = 1
                    }
                else
                    item_groups[sec].count = item_groups[sec].count + 1
                end
            end

            local item_names = {}
            
            for _, group in pairs(item_groups) do
                local inv_name = ui_item.get_sec_name(group.section)
                if group.count > 1 then
                    table.insert(item_names, tostring(group.count).." x "..inv_name)                    
                else
                    table.insert(item_names, inv_name)                    
                end
            end
            
            msg = msg..table.concat(item_names, ", ")

            local ui_sender = news_manager.tips_icons['default']
            db.actor:give_game_news("", msg, ui_sender, 0, 20000)
            
            stash_data.examine = true
        end
    end
end

local function actor_on_item_take_from_box(box,obj)
    if not IsSoulslikeMode() then
        return
    end

    local data = get_soulslike_state()
    local id = box:id()

    debug('Player opened stash id '..tostring(id))
    
	if (box:section() == "inv_backpack") then
        if (box:is_inv_box_empty()) then
            hide_hud_inventory()
            
            local se_obj = alife_object(id)

            if se_obj then
                alife_release(se_obj)
                try_send_inventory_examined_message(id)
                data.created_stashes[id] = nil
            end
        end
	end
end

local function actor_on_stash_remove(data)
    if not IsSoulslikeMode() then
        return
    end

    local data = get_soulslike_state()

    if data.created_stashes[data.stash_id] then
        data.cancel = true    
        try_send_inventory_examined_message(data.stash_id)
    end
end

local function on_console_execute(name, ...)
    if not IsSoulslikeMode() then
        return
    end

    if(name == "save") then
        debug(name)
        local extraArgs = {...}

        if extraArgs then
            local file_name = table.concat(extraArgs," ")
            debug(file_name)
            if soulslike_mcm.is_hardcore_save_enabled() then
                remove_prior_saves(file_name)
            end
        end
    end
end

local function physic_object_on_use_callback(box, who)
    local data = get_soulslike_state()

    if not IsInvbox(box) or not data.hidden_stashes or not data.hidden_stashes[box:id()] then
        return
    end

    local id = box:id()
    local stash_data = data.hidden_stashes[id]
    local stash_id = stash_data.stash_id
    local stash = level.object_by_id(stash_id)

    if not stash then        
        debug("Not expected, unable to find stash id linked to Invbox.. ")
    end

    local function transfer_item(temp,item)
        debug("Transfering item "..item:section())    
        stash:transfer_item(item, box)
    end

    if stash_data.radio_id then
	    item_radio.clear_stash(stash_data.radio_id) 
    end 

	item_radio.clear_stash(stash_data.stash_id) 

    debug("Transfering items from hidden stash "..tostring(id).." to static stash "..tostring(stash_id))    
    stash:iterate_inventory_box(transfer_item)      
    alife_release(stash)

    debug("Removing PDA marker "..tostring(id))   
    level.map_remove_object_spot(id , "secondary_task_location")

    data.hidden_stashes[id] = nil
end

local function load_state(data) 
    if not IsSoulslikeMode() then
        return
    end

    local data = get_soulslike_state()

    if data.logic_state then
        -- Reinitialize the last scenario using the saved logic state.
        scenario_logic = soulslike_scenario_logic_factory.create(data.logic_state.scenario_id, data.logic_state)
    end
end

local function save_state(data) 
    if not IsSoulslikeMode() then
        return
    end

    local data = get_soulslike_state()

    if not data.spawn_location.level and level.name() ~= 'fake_start' then
        set_spawn(false)
    end

    if scenario_logic then
        -- Save the logic state for the current scenario so we can restore it on load
        -- This is for the purposes of ChangeLevel which unloads the scripts and then 
        -- reloads them, so we need to be able to reinitialize the scenario as it was
        -- before changing levels
        data.logic_state = scenario_logic.logic_state;
    end
end

local function on_level_changing() 
    if not IsSoulslikeMode() then
        return
    end

    debug("On on_level_changing load.")
    local data = get_soulslike_state()

    if not data.spawn_location.level and level.name() ~= 'fake_start' then
        set_spawn(false)
    end
end

local function on_game_load()
    if not IsSoulslikeMode() then
        return
    end

    debug("On game load.")

    local data = get_soulslike_state()

    -- Write out an identifier so we can use it later
    -- to identify other saves with the same ID if the 
    -- user is playing with Hardcore Saves enabled.
    if not data.uuid then        
        data.uuid = GAME_VERSION .. "_" .. tostring(math.random(100)) .. tostring(math.random()) .. tostring(math.random(1000))
    end

    debug("Looking for scenario logic.")

    if scenario_logic then
        debug("Calling scenario respawn.")
        scenario_logic:OnRespawn()
    end
end 

local function actor_on_sleep(hours)    
    if not IsSoulslikeMode() then
        return
    end

    soulslike.debug('actor_on_sleep')

    -- Only force save if we aren't running a scenario 
    if not scenario_logic then
        soulslike.force_save("sleep")
    end
end


function on_game_start()
    debug('Version: '..version)

    RegisterScriptCallback("actor_on_stash_remove", actor_on_stash_remove)
    RegisterScriptCallback("actor_on_item_take_from_box", actor_on_item_take_from_box)
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
    RegisterScriptCallback("on_before_save_input", on_before_save_input)
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("on_level_changing", on_level_changing)
    RegisterScriptCallback("on_game_load", on_game_load)
    RegisterScriptCallback("actor_on_sleep", actor_on_sleep)
	RegisterScriptCallback("on_console_execute", on_console_execute)
	RegisterScriptCallback("physic_object_on_use_callback", physic_object_on_use_callback)
end
